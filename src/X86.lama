-- X86 codegeneration interface
-- We use stack machine programs as intermediate representation
import SM;
import Collection;
import List;
import Buffer;
import Fun;
import Manifest;
import Expr; -- for apply

-- Assembler language interface
-- The registers: 
local regs = ["%ebx", "%ecx", "%esi", "%edi", "%eax", "%edx", "%ebp", "%esp"];

-- We can not freely operate with all register; only with 4 by now
local nRegs = regs.length - 5;

-- For convenience we define the following synonyms for the registers: 
local ebx = R (0),
      ecx = R (1),
      esi = R (2),
      edi = R (3),
      eax = R (4),
      edx = R (5),
      ebp = R (6),
      esp = R (7);

-- We need to know the word size to calculate offsets correctly
local wordSize = 4;

fun opndString (opnd) {
  case opnd of
    R (i) -> regs [i]
  | S (i) -> sprintf ("-%d(%%ebp)", (i+1) * wordSize)
  | M (x) -> x
  | L (i) -> sprintf ("$%d", i)
  esac
}

-- We need to distinguish the following operand types: 
--    R (int)    -- hard register                    
--    S (int)    -- a position on the hardware stack 
--    M (string) -- a named memory location          
--    L (int)    -- an immediate operand             

-- Some x86 instruction (we do not need all of them):
--   Mov   (opnd, opnd)         -- copies a value from the first to the second operand  
--   Binop (string, opnd, opnd) -- makes a binary operation; note, the first operand   
--                                 designates x86 operator, not the source language one
--   IDiv  (opnd)               -- x86 integer division, see instruction set reference 
--   Cltd                       -- see instruction set reference           
--   Set   (string, string)     -- sets a value from flags; the first operand is the   
--                                 suffix, which determines the value being set, the
--                                 the second --- (sub)register name 
--   Push  (opnd)               -- pushes the operand on the hardware stack
--   Pop   (opnd)               -- pops from the hardware stack to the operand
--   Call  (string)             -- calls a function by its name 
--   Ret                        -- returns from a function
--   Meta  (string)             -- metainformation (declarations, etc.)
                                                               
-- Machine instruction printer
fun insnString (insn) {
  
  fun binopString (op) {
    case op of
      "+"   -> "addl"
    | "-"   -> "subl"
    | "*"   -> "imull"
    | "&&"  -> "andl"
    | "!!"  -> "orl" 
    | "^"   -> "xorl"
    | "cmp" -> "cmpl"
    | "test" -> "testl"
    esac
  }
  
  case insn of
    Cltd               -> "\tcltd\n"
  | Set   (suf, s)     -> sprintf ("\tset%s\t%s\n", suf, s)
  | IDiv  (s1)         -> sprintf ("\tidivl\t%s\n", opndString (s1))
  | Binop (op, s1, s2) -> sprintf ("\t%s\t%s,\t%s\n", binopString (op), opndString (s1), opndString (s2))
  | Mov   (s1, s2)     -> sprintf ("\tmovl\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Push  (s)          -> sprintf ("\tpushl\t%s\n", opndString (s))
  | Pop   (s)          -> sprintf ("\tpopl\t%s\n", opndString (s))
  | Ret                -> "\tret\n"
  | Call  (p)          -> sprintf ("\tcall\t%s\n", p)
  | Meta  (m)          -> m
  esac
}

-- Environment for symbolic interpreter
-- An environment holds
--    a symbolic stack
--    a maximal stack depth reached so far
--    a set of global variable names

fun makeEnv (stack, stackSlots, globals, unusedLockals) {

  -- Returns an internal name for a global variable
  fun globalName (name) {
    "global_" ++ name
  }

  -- Returns a string representation of the environment
  fun envString () {
    sprintf ("Stack     : %s\nStackSlots: %d\nGlobals   : %s\n", stack.string, stackSlots, elements (globals).string)
  }
  
  -- Allocates a new position on the symbolic stack or reuse existed;
  -- returns a pair: a location for allocated item and
  -- an updated environment
  fun allocate () {
    if unusedLockals.size then
      case unusedLockals of x:tl ->
        return [x, makeEnv(x : stack, stackSlots, globals, tl)]
      esac
    fi;
    [S (stackSlots), makeEnv (S (stackSlots) : stack, stackSlots + 1, globals, unusedLockals)]
  }

  -- Pushes an item on the symbolic state; returns an updated envirtonment
  fun push (y) {
    makeEnv (y : stack, stackSlots, globals, remove(fun (x) {compare(x, y) == 0}, unusedLockals))
  }

  -- Adds local variable to list of unused; return updated list
  fun dealloc(unusedLockals, x) {
      if regOpnd(x) then x : unusedLockals
      elif stackOpnd(x) then unusedLockals +++ singleton(x)
      else unusedLockals fi
  }

  -- Pops one item from the symbolic stack; returns a pair: a popped
  -- item and an updated environment
  fun pop () {
    case stack of
      x : stack -> [x, makeEnv (stack, stackSlots, globals, dealloc(unusedLockals, x))]
    esac
  }

  -- Pops two items from the symbolic stack; returns a triple:
  -- popped items and an updated environment
  fun pop2 () {
    case stack of
      x : y : stack ->
        [x, y, makeEnv (stack, stackSlots, globals, dealloc(dealloc(unusedLockals, x), y))]
    esac
  }

  -- Adds a global variable; returns an updated environment
  fun addGlobal (name) {
    makeEnv (stack, stackSlots, addSet (globals, globalName (name)), unusedLockals)
  }

  -- References a global variable
  fun loc (name) {
    M (globalName (name))
  }
  
  -- Gets a list of global variables from the environment
  fun getGlobals () {
    globals.elements
  }

  -- Gets a maximal stack size from the environment
  fun getStackSize () {
    stackSlots
  }
  [envString, allocate, push, pop, pop2, addGlobal, loc, getGlobals, getStackSize]
}

-- Exported accessors
fun envString (env) {
  env [0] ()
}

fun allocate (env) {
  env [1] ()
}

fun push (env, x) {
  env [2] (x)
}

fun pop (env) {
  env [3] ()
}

fun pop2 (env) {
  env [4] ()
}

fun addGlobal (env, name) {
  env [5] (name)
}

fun loc (env, name) {
  env [6] (name)
}

fun getGlobals (env) {
  env [7] ()
}

fun getStackSize (env) {
  env [8] ()
}

-- Creates an initial environment
fun initEnv () {
  makeEnv ({}, 0, emptySet (compare), {R (0), R (1), R(2), R(3)})
}

-- Codegeneration helper functions
-- Generates code section
fun codeSection (text) {
  singletonBuffer (Meta ("\t.text\n")) <+> text
}

-- Generates data section
fun dataSection (text) {
  singletonBuffer (Meta ("\t.data\n")) <+> text
}

-- Generates data definition
fun dataDef (name) {
  Meta (sprintf ("%s:\t.int\t0\n", name))
}

-- Generates function prologue
fun prologue (size) {
  singletonBuffer (Push (ebp)) <+
  Mov   (esp, ebp) <+
  Binop ("-", L (wordSize*size), esp)
}

-- Generates function epilogue
fun epilogue () {
  singletonBuffer (Mov (ebp, esp)) <+
  Pop   (ebp) <+
  Binop ("^", eax, eax) <+
  Ret
}

-- Checks if an operand resides on a stack
fun stackOpnd (opnd) {
  case opnd of
    S (_) -> true
  | _     -> false
  esac      
}

-- Checks if an operand resides in memory
fun memOpnd (opnd) {
  case opnd of
    S (_) -> true
  | M (_) -> true
  | _     -> false
  esac
}

-- Checks if an operand resides in constant
fun constOpnd (opnd) {
  case opnd of
    L (_) -> true
  | _     -> false
  esac
}

-- Checks if an operand resides in register
fun regOpnd (opnd) {
  case opnd of
    R (_) -> true
  | _     -> false
  esac
}

-- Checks if an operand resides in global variable
fun globalOpnd (opnd) {
  case opnd of
    M (_) -> true
  | _     -> false
  esac
}

-- Checks if an operand resides in local variable
fun localOpnd (opnd) {
  case opnd of
    S (_) -> true
  | R (_) -> true
  | _     -> false
  esac
}

-- Checks if an operation is commutative
fun commutativeOper(op) {
    case op of
      "+"  -> true |
      "*"  -> true |
      "&&" -> true |
      "!!" -> true |
      "==" -> true |
      "!=" -> true |
      _    -> false
    esac
}

-- Generates a move between locations, using
-- intermediate register if needed
fun move (from, to) {
  if from == to then
    return emptyBuffer()
  fi;
  if memOpnd (from) && memOpnd (to)
  then singletonBuffer (Mov (from, eax)) <+ Mov (eax, to)
  else singletonBuffer (Mov (from, to))
  fi
}

-- Gets a suffix for Set instruction from
-- source language comparison operator
fun suffix (op) {
  case op of
    "<"  -> "l"
  | "<=" -> "le"
  | "==" -> "e"
  | "!=" -> "ne"
  | ">=" -> "ge"
  | ">"  -> "g"
  | _    -> None
  esac
}

-- Swap operands for compare: (a < b) -> (b > a)
fun reversed (op) {
  case op of
    "<"  -> ">"
  | "<=" -> ">="
  | "==" -> "=="
  | "!=" -> "!="
  | ">=" -> "<="
  | ">"  -> "<"
  | _    -> None
  esac
}

-- Returns string representation of least byte of value 
fun leastByte(x) {
  case x of
    R (0) -> "%bl" |
    R (1) -> "%cl" |
    R (4) -> "%al" |
    R (5) -> "%dl" |
    s@S (_) -> opndString(s) |
    _ -> None
  esac
}

-- Compiles stack machine code into a list of x86 instructions. Takes an environment
-- and stack machine code, returns an updated environment and x86 code.
fun compile (env, code) {
  fun compile (env, code) {
    foldl (
      fun ([env, scode], i) {
        local code = scode <+ Meta ("# " ++ showSMInsn (i) ++ "\n");
        case i of
          READ ->
            case allocate(env) of
              [s, env] -> [env, code <+ Call ("Lread") <+ Mov (eax, s)]
            esac             
        | WRITE ->
            case pop(env) of
              [s, env] -> [env, code <+ Push (s) <+ Call ("Lwrite") <+ Pop (eax)]
            esac
        | ST (x) ->
            case pop(addGlobal(env, x)) of
              [s, env] -> [env, code <+> move(s, env.loc(x))]
            esac
        | LD (x) ->
            case addGlobal(env, x) of
              env -> [push(env, loc(env, x)), code]
            esac
        | CONST (x) ->
            [push(env, L (x)), code]
        | BINOP (op) ->
            case 
              case pop2(env) of
                [op2, op1, env] ->
                if commutativeOper(op) && localOpnd(op2) then
                  [op1, op2, env]
                else
                  [op2, op1, env]
                fi
              esac
            of
              [op2, op1, env] ->
                if constOpnd(op1) && constOpnd(op2) then 
                  [push(env, L (apply(op, op1[0], op2[0]))), code]
                elif compare(op, "/") == 0 !! compare(op, "%") == 0 then
                  case allocate(env) of
                    [s, env] -> [env, code <+
                      Mov(op1, eax) <+ Cltd <+>
                      listBuffer(if constOpnd(op2) then singleton(Mov(op2, s)) else {} fi) <+
                      IDiv(if constOpnd(op2) then s else op2 fi) <+
                      if compare(op, "/") == 0 then Mov(eax, s) else Mov(edx, s) fi
                    ]
                  esac
                elif compare(op, "&&") == 0 !! compare(op, "!!") == 0 then -- TODO: optimize test for boolean values
                  case allocate(env) of
                    [s, env] -> [env, code <+>
                      if regOpnd(op1) then singletonBuffer(Binop("test", op1, op1))
                      else listBuffer({Mov(op1, eax), Binop("test", eax, eax)}) fi
                      <+ Set("nz", "%dl") <+>
                      if regOpnd(op2) then singletonBuffer(Binop("test", op2, op2))
                      else listBuffer({Mov(op2, eax), Binop("test", eax, eax)}) fi
                      <+ Set("nz", "%al") <+ Mov(eax, s) <+ Binop(op, edx, s) <+ Binop("&&", L (1), s)
                    ]
                  esac
                elif compare(suffix(op), None) != 0 then
                  case allocate(env) of
                    [s, env] -> [env, code <+>
                      if constOpnd(op1) then
                        singletonBuffer(Binop("cmp", op1, op2))
                      elif memOpnd(op1) && memOpnd(op2) then 
                        listBuffer({Mov(op1, eax), Binop("cmp", op2, eax)})
                      else
                        singletonBuffer(Binop("cmp", op2, op1))
                      fi <+>
                      case suffix(if constOpnd(op1) then reversed(op) else op fi) of
                        suf -> case leastByte(s) of
                          None -> listBuffer({Set(suf, "%al"), Mov(eax, s)}) |
                          s -> singletonBuffer(Set(suf, s))
                        esac
                      esac <+ Binop("&&", L (1), s)
                    ]
                  esac
                elif compare(op, "*") == 0 then -- TODO: Add trernary imull
                  case 
                    if regOpnd(op1) then 
                      [op1, [op1, push(env, op1)]]
                    else
                      [edx, allocate(env)]
                    fi
                  of
                    [tmp, [s, env]] -> [env, code <+> move(op1, tmp) <+>
                      if constOpnd(op2) then
                        listBuffer({Mov (op2, eax), Binop (op, eax, tmp)})
                      else
                        singletonBuffer(Binop (op, op2, tmp))
                      fi <+> move(tmp, s)
                    ]
                  esac
                else -- TODO: maybe optimize
                  case if localOpnd(op1) then [op1, push(push(env, op2), op1)] else allocate(push(env, op2)) fi of
                    [s, env] -> [case pop2(env) of [x, op2, env] -> push(env, x) esac, code <+>
                      move(op1, s) <+>
                      if memOpnd(op2) && memOpnd(s) then
                        listBuffer({Mov(op2, eax), Binop(op, eax, s)})
                      else
                        singletonBuffer(Binop(op, op2, s))
                      fi
                    ]
                  esac
                fi
            esac
        | _ -> failure ("codegeneration for instruction %s is not yet implemented\n", i.string)
        esac
      }, [env, emptyBuffer ()], code)
  }

  compile (env, code) 
}

public fun compileX86 (args, code) {
  case compile (initEnv (), code) of
    [env, code] ->
       local asmFile = args.getBaseName ++ ".s",
             runtime = case getEnv ("LAMA_RUNTIME") of
                         #unboxed -> "../runtime/"
                       | path     -> path
                       esac ++ "/runtime.o";
       
       fwrite (asmFile,
               map (insnString, 
                    getBuffer $
                      singletonBuffer (Meta ("\t.global\tmain\n")) <+>
                      dataSection (listBuffer $ map (dataDef, getGlobals (env))) <+>
                      codeSection (
                        singletonBuffer (Meta ("main:\n")) <+>
                        prologue (getStackSize (env)) <+>
                        code <+>
                        epilogue ()
                      )
                    ).stringcat);
                    
       system ({"gcc -g -m32 -o ", args.getBaseName, " ", runtime, " ", asmFile}.stringcat)
  esac
}
