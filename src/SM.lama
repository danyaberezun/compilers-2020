-- Stack machine.

import List;
import World;
import State;
import Expr;

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
-- Instruction = READ | WRITE | BINOP String | LD X | ST X | CONST N

fun eval(c@[s, st, w], insns) {
  case insns of
    READ: p       -> local ss; ss := readWorld(w); eval([ss[0] : s, st, ss[1]], p)
  | WRITE: p      -> eval([s[1], st, writeWorld(s[0], w)], p)
  | BINOP (op): p -> eval([evalOp(op, s[1][0], s[0]) : s[1][1], st, w], p)
  | LD (x): p     -> eval([st (x) : s, st, w], p)
  | ST (x): p     -> eval([s[1], (st <- [x,s[0]]), w], p)
  | CONST (n): p  -> eval ([n : s, st, w], p)
  | {} -> c
  esac
}
  
-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions

fun compileExpr ( expr ) {
  case expr of 
    Var   ( x )                -> singleton   ( LD    ( x ) )
  | Const ( n )                -> singleton   ( CONST ( n ) )
  | Binop ( op, expr1, expr2 ) -> compileExpr ( expr1 ) +++ compileExpr ( expr2 ) +++ singleton ( BINOP ( op ))
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.

public fun compileSM (stmt) {
  case stmt of
    Assn  ( st, expr )      -> compileExpr ( expr ) +++ singleton ( ST ( st ))
  | Read  ( s )            -> { READ, ST(s) }
  | Write ( expr )         -> compileExpr ( expr ) +++ singleton ( WRITE )
  | Seq   ( stmt1, stmt2 ) -> compileSM ( stmt1 ) +++ compileSM ( stmt2 )
  | Skip                   -> {}
  esac
}
