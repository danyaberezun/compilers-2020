-- Stack machine.

import List;
import World;
import State;
import Expr;

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
-- Instruction = READ | WRITE | BINOP String | LD X | ST X | CONST N
fun eval (c, insns) {
  case insns of
    {}     -> c
  | ins : new_insns -> case c of 
                         [ stack, state, world] -> eval( case ins of
        CONST (n)  -> [ n : stack, state, world ]
      | BINOP (op) -> case stack of 
            x : y : rest -> [ binop_operations (op) (x, y) : rest, state, world ] 
         esac
      | READ       -> 
          case readWorld (world) of 
               [ a, world_ ] -> [ a : stack, state, world_ ]
          esac
      | WRITE      -> case stack of ( x : rest) -> {
               local nworld;
               nworld := writeWorld(x,world);
               [rest,state,nworld]
          } 
          esac
      | LD    (x)  -> [ state (x) : stack, state, world ]
      | ST    (x)  -> case stack of 
           a : rest -> [ rest, state <- [ x, a ], world ] 
         esac
      esac, new_insns)
    esac
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) {
   case expr of
     Var(x) -> singleton (LD (x)) 
    |Const(n) -> CONST(n)
    |Binop(op, l, r) -> compileExpr(r) +++ compileExpr(l) +++ singleton(BINOP(op)) 
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  case stmt of
           Skip -> {} 
          | Assn(x, expr) -> {compileExpr(expr),singleton(ST(x))} 
          | Read(x) -> {singleton(READ), singleton(ST(x)} 
          | Write(eexpr) -> {compileExpr(expr), singleton(WRITE)}
          | Seq(s1, s2) -> {compileSM(s1), compileSM(s2)}
  esac
}
