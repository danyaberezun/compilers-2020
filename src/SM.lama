-- Stack machine.

import List;
import World;
import State;
import Expr;

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
-- Instruction = READ | WRITE | BINOP String | LD X | ST X | CONST N
fun eval (cc@[s, st, ww@[i,o]], insns) {
  case insns of
    LD (x): p -> eval([st (x) : s, st, ww], p)
  | ST (x): p -> case s of y : ss -> eval ([s, (st <- [x,y]), ww], p) esac
  | CONST (n): p -> eval ([n : s, st, ww], p)
  | BINOP (op): p -> case s of x : y: ss -> eval ([evalOp (op, y, x): ss, st, ww], p) esac
  | READ: p -> case i of x : it -> eval ([x : s, st, [it, o]], p) esac
  | WRITE: p -> case s of x : ss -> eval ([ss, st, [i, x : o]], p) esac
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) {
  case expr of
    Var (x) -> singleton (LD (x))
  | Const (s) -> singleton (CONST (s))
  | Binop (op, expr1, expr2) -> compileExpr (expr1) +++ compileExpr (expr2) +++ singleton (BINOP (op))
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  case stmt of
    Assn (s, expr) -> compileExpr (expr) +++ singleton (ST (s))
  | Seq (stmt1, stmt2) -> return compileSM (stmt1) +++ compileSM (stmt2)
  | Skip -> {}
  | Read (s) -> singleton (READ) +++ singleton (ST (s))
  | Write (expr) -> compileExpr (expr) +++ singleton (WRITE)
	esac
}
