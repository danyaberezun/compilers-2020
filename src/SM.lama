-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ      -> sprintf ("READ")
  | WRITE     -> sprintf ("WRITE")
  | BINOP (s) -> sprintf ("BINOP %s", s)
  | LD    (x) -> sprintf ("LD %s", x)
  | ST    (x) -> sprintf ("ST %s", x)
  | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
-- Instruction = READ | WRITE | BINOP String | LD X | ST X | CONST N

fun eval (configuration, insns) {
	case configuration of
    [stack, st, world@[i, o]] -> case insns of
        {} -> configuration
      | READ      	: tail -> case i of 
							x : it     -> eval ([x : stack, st, [it, o]], tail) -- 
						   esac
      | WRITE     	: tail -> case stack of 
							x : ss     -> eval ([ss, st, [i, x : o]], tail)
						   esac
      | BINOP (str) : tail -> case stack of 
							x : y : ss -> eval ([binopTranslate (str, y, x) : ss, st, world], tail) 
						   esac
      | LD    (x) 	: tail -> eval ([st (x) : stack, st, world], tail)
      | ST    (x) 	: tail -> case stack of 
							y : ss -> eval ([stack, (st <- [x, y]), world], tail) 
						   esac
      | CONST (n) 	: tail -> eval ([n : stack, st, world], tail)
    esac
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output

public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions

fun compileExpr (expr) {
	case expr of 
	Var   (x)         		 -> singleton 	(LD (x))
	| Const (n)         		 -> singleton   (CONST (n))
	| Binop (op, left, right) -> compileExpr (left) +++ compileExpr (right) +++ singleton (BINOP (op))
	esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.

public fun compileSM (stmt) {
	case stmt of
	  Assn (x, expr) -> compileExpr (expr) +++ singleton (ST (x))
	| Read (x)       -> {READ,                 ST (x)           }
	| Write (expr)   -> compileExpr (expr) +++ singleton (WRITE)
	| Seq (s1, s2)   -> compileSM (s1)     +++ compileSM (s2)
	esac
}
