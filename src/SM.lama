-- Stack machine.

import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Expr;
import Buffer;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ         -> sprintf ("READ")
  | WRITE        -> sprintf ("WRITE")
  | BINOP (s)    -> sprintf ("BINOP %s", s)
  | LD    (x)    -> sprintf ("LD %s", x)
  | ST    (x)    -> sprintf ("ST %s", x)
  | CONST (n)    -> sprintf ("CONST %d", n)
  | LABEL (s)    -> sprintf ("LABEL %s", s)
  | JMP   (l)    -> sprintf ("JMP %s", l)
  | CJMP  (c, l) -> sprintf ("CJMP %s, %s", c, l)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  local map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];
  
  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}

-- Stack machine interpreter. Takes an environment, an SM-configuration and a program,
-- returns a final configuration
fun eval (env, c@[stack, state, w], insns) {

  case insns of {} -> c | insn : p ->
    case insn of
      READ          -> local new_w = readWorld(w); eval( env, [new_w[0] : stack, state, new_w[1]], p )
    | WRITE         -> eval( env, [stack[1], state, writeWorld(stack[0], w)], p )
    | BINOP (op)    -> eval( env, [evalOp(op, stack[1][0], stack[0]) : stack[1][1], state, w], p )
    | CONST (n)     -> eval( env, [n : stack, state, w], p )
    | LD    (x)     -> eval( env, [state(x) : stack, state, w], p )
    | ST    (x)     -> eval( env, [stack[1], state <- [x, stack[0]], w], p )
    | LABEL (s)     -> eval( env, c, p )
    | JMP   (l)     -> eval( env, c, fromLabel(env, l) )
    | CJMP  (con, l)-> eval( env, c,  case stack of head:r ->
                                        case con of 
                                          "nz" -> if head then fromLabel(env, l) else p fi 
                                        | _    -> if head then p else fromLabel(env, l) fi
                                        esac
                                      esac )
    esac
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval (initEvalEnv (insns), [{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compilation environment: generates labels
fun makeCompEnv (n) {
  [fun () {
     [sprintf ("L%d", n), makeCompEnv (n+1)]
  }]
}

fun initCompEnv () {
  makeCompEnv (0)
}

-- Accessor function: generates one label
fun genLabel (env) {
  env [0] ()
}

-- Utility function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then singleton (env)
    else case env.genLabel of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) {

  case expr of
    Var (str)         -> singleton( LD(str) )
  | Const (int)       -> singleton( CONST(int) )
  | Binop (op, l, r)  -> compileExpr(l) +++ compileExpr(r) +++ singleton(BINOP(op))
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {

  fun compileEnv(env, stmt) {
    case stmt of
      Assn (x, expr)      ->  [ env, compileExpr(expr) +++ (ST(x):{}) ]
    | Skip                ->  [ env, {} ]
    | Read (x)            ->  [ env, (READ:{})+++(ST(x):{}) ]
    | Write (expr)        ->  [ env, compileExpr(expr) +++ (WRITE:{}) ]

    | Seq (stmt1, stmt2)  ->  case compileEnv(env, stmt1) of [env1, s1] -> 
                                case compileEnv(env1, stmt2) of [env2, s2] -> 
                                  [ env2, s1+++s2 ] 
                                esac
                              esac

    | If (expr, s1, s2)   ->  case genLabels(env, 2) of [el, exit, env1] ->
                                case compileEnv(env1, s1) of [env2, stmt1] ->
                                case compileEnv(env2, s2) of [env3, stmt2] ->
                                  [ env3, compileExpr(expr)+++(CJMP("z", el):{})+++stmt1+++(JMP(exit):{})+++(LABEL(el):{})+++stmt2+++(LABEL(exit):{}) ]
                                esac
                                esac
                              esac

    | While (expr, stmt)  ->  case genLabels(env, 2) of [le,ls,env1] -> 
                                case compileEnv(env1, stmt) of [env2, s] ->
                                  [ env2, { JMP(le), LABEL(ls) } +++ s +++ (LABEL(le):{}) +++ compileExpr(expr) +++ singleton(CJMP("nz", ls)) ]
                                esac
                              esac

    | Repeat (stmt, expr) ->  case compileEnv(env, stmt) of [env1, s] ->
                                case genLabel(env1) of [rep, env2] ->
                                  [ env2, (LABEL(rep):{})+++s+++compileExpr(expr)+++(CJMP("z", rep):{}) ]
                                esac
                              esac
    esac
  }
  compileEnv(initCompEnv(), stmt)[1]
}
