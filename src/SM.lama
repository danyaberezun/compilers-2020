-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration

fun eval (c, insns) {
	local st;
	st := c[0];
	local env;
	env := c[1];
	local wrld;
	wrld := c[2];
	case insns of
		  {} -> c
		| x:xs -> {

      		conf := 
        	case x of 
          		BINOP (op) -> case st of 
          			y:x:st -> [(evalExpr (env, Binop (op, Const (x), Const (y)))):st, env, wrld]
          			esac
          		| ST (x) -> case st of z:st -> [st, env <- [x, z], wrld] esac
        		| LD (x) -> [env(x):st, env, wrld]
        		| CONST(c) -> [c:st, env, wrld]
        		| READ -> case readWorld (wrld) of [z, wrld] -> [z:st, env, wrld] esac
        		| WRITE      -> case st of z:st -> [st, env, writeWorld (z, wrld)] esac
        esac;

      eval (conf, xs)
    }
  esac
}



-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) 
{
	case expr of
		  Var (x) -> return singleton(LD(x))
		| Const (n) -> return singleton(CONST(n))
		| Binop (op, l, r) -> return compileExpr(l) +++ compileExpr(r) +++        singleton(BINOP(op))
	esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  case stmt of
		  Assn(s, expr) -> return compileExpr(expr) +++ singleton(ST(s))
		| Seq (l, r) -> return compileSM (l) +++ compileSM (r)
		| Skip -> {}
		| Read (s) -> return singleton(READ) +++ singleton(ST(s))
		| Write (expr) -> return compileExpr(expr) +++ singleton(WRITE)
	esac
}
