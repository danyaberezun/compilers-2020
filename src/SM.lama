-- Stack machine.

import Ref;
import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Parser;
import Lexer;
import Expr;
import Buffer;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  -- Shows a location (a reference to function argument, local or global variable)
  fun showLoc (d) {
    case d of
      Arg (i) -> sprintf ("arg[%d]", i)
    | Loc (i) -> sprintf ("loc[%d]", i)
    | Glb (x) -> x
    esac
  }
  
  case i of
    READ             -> "READ"
  | WRITE            -> "WRITE"
  | BINOP  (s)       -> sprintf ("BINOP %s", s)
  | LD     (x)       -> sprintf ("LD %s", showLoc (x))
  | LDA    (x)       -> sprintf ("LDA %s", showLoc (x))
  | ST     (x)       -> sprintf ("ST %s", showLoc (x))
  | STI              -> "STI"
  | CONST  (n)       -> sprintf ("CONST %d", n)
  | LABEL  (s)       -> sprintf ("LABEL %s", s)
  | JMP    (l)       -> sprintf ("JMP %s", l)
  | CJMP   (c, l)    -> sprintf ("CJMP %s, %s", c, l)
  | CALL   (f, n)    -> sprintf ("CALL %s, %d", f, n)
  | BEGIN  (f, a, l) -> sprintf ("BEGIN %s, %d, %d", f, a, l)
  | GLOBAL (x)       -> sprintf ("GLOBAL %s", x)
  | END              -> sprintf ("END")
  | DUP              -> "DUP"
  | DROP             -> "DROP"  
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  local map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];
  
  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}

-- Stack machine interpreter. Takes an environment, a world and a program,
-- returns a final output
fun eval (env, w, insns) {
  -- Global state maps names of global variables to values
  local globalState = ref (fun (x) {error (sprintf ("name ""%s"" is undefined", x), getLoc (x))});
  
  -- Make a fresh local state: a pair of arrays for arguments and local variables;
  -- takes the numbers of arguments and local variables respectively
  fun makeState (a, l) {
    [initArray (a, fun (_) {0}), initArray (l, fun (_) {0})]
  }

  -- Lookups a location in local/global states
  fun lookup ([args, locs], loc) {
    case loc of
      Arg (i) -> args[i]
    | Loc (i) -> locs[i]
    | Glb (x) -> deref (globalState) (x)
    esac 
  }

  -- Assigns a value to a location
  fun assign ([args, locs], loc, val) {
    case loc of
      Arg (i) -> args[i] := val
    | Loc (i) -> locs[i] := val
    | Glb (x) -> local g = deref (globalState);
                 globalState ::= fun (y) {if compare (x, y) == 0 then val else g (y) fi}
    esac
  }

  -- Takes n positions from the list, retursn a pair: the remaining list and the taken
  -- sublist
  fun take (list, n) {
    fun inner (n, acc, list) {
      if n == 0
      then [list, acc]
      else inner (n-1, list.hd : acc, list.tl)
      fi
    }

    inner (n, {}, list)
  }

  fun createLocal(stack, nargs, nlocals) {
    case take(stack, nargs) of [stack, args] ->
      local state = makeState(nargs, nlocals);
      foldl(fun(i, arg) {
        assign(state, Arg (i), arg);
        i + 1
      }, 0, args);
      [stack, state]
    esac
  }

  -- Core interpreter: takes a configuration and a program, returns a configuration
  (* Assignment *)
  fun eval (configuration@[st, cst, s, w], commands) {
    while 1 do {
      case commands of
        {} -> return configuration
      | command:commandsTail ->
          case eval1(env, configuration, command, commandsTail) of
            [configuration2, commandsTail2] ->
              commands := commandsTail2;
              configuration := configuration2
          esac
      esac
    } od
  }

  fun eval1 (env, configuration@[stack, controlStack, state, world], command, commands) {
    --printf("eval1:        %s\n", stack.string);
    --printf("eval1:        %s\n", globalState.string);
    --printf("eval1:        %s\n", state.string);
    --printf("eval1:    %s\n", command.string);
    case command of
      BINOP (op) ->
        case stack of value2:value1:stack2 ->
          local value = evalBinop(op, value1, value2);
          stack := value:stack2
        esac
    | CONST (value) ->
        stack := value:stack
    | DUP ->
        case stack of value:stack2 ->
          stack := value:value:stack2
        esac
    | DROP ->
        case stack of value:stack2 ->
          stack := stack2
        esac
    | READ ->
        case readWorld(world) of [value, world2] ->
          stack := value:stack;
          world := world2
        esac
    | WRITE ->
        case stack of value:stack2 ->
          local world2 = writeWorld(value, world);
          stack := stack2;
          world := world2
        esac
    | LD (var) ->
        stack := lookup(state, var) : stack
    | LDA (var) ->
        stack := Ref (var) : stack
    | ST (var) ->
        case stack of value:stack2 ->
          assign(state, var, value)
        esac
    | STI ->
        case stack of value : Ref (var) : stack2 ->
          stack := value:stack2;
          assign(state, var, value)
        esac
    | GLOBAL (name) -> {}
    | LABEL (label) -> {}
    | JMP (label) ->
        commands := fromLabel(env, label)
    | CJMP (code, label) ->
        case stack of value:stack2 ->
          local code_is_zero = compare(code, "z") == 0;
          if (value == 0) == code_is_zero then
            commands := fromLabel(env, label)
          fi;
          stack := stack2
        esac
    | CALL (fLabel, _) ->
        controlStack := [state, commands] : controlStack;
        commands := fromLabel(env, fLabel)
    | BEGIN (fLabel, nargs, nlocals) ->
        case createLocal(stack, nargs, nlocals) of [stack2, state2] ->
          stack := stack2;
          state := state2
        esac
    | END ->
        case controlStack of
          {} -> commands := {}
        | [state2, commands2] : controlStack2 ->
            controlStack := controlStack2;
            state := state2;
            commands := commands2
        esac
    --| CALL
    esac;
    return [[stack, controlStack, state, world], commands]
  }

  (* End *)
  
  eval ([{}, {}, makeState (0, 0), w], insns) [3].getOutput
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval (initEvalEnv (insns), createWorld (input), insns)
}

-- Compilation environment: generates labels
fun makeCompEnv (nLabels, scopeDepth, state, nLocals, nArgs, functions) {
  -- Generates a new label
  fun genLabel () {
    [sprintf ("L%d", nLabels), makeCompEnv (nLabels+1, scopeDepth, state, nLocals, nArgs, functions)]
  }

  -- Adds a new function 
  fun rememberFun (fLabel, args, body) {
    makeCompEnv (nLabels,
                 scopeDepth,
                 state,
                 nLocals,
                 nArgs,
                 Fun (fLabel, args, body, state) : functions)
  }

  -- Enters a local scope
  fun beginScope () {
    makeCompEnv (nLabels, scopeDepth+1, enterScope (state), nLocals, nArgs, functions)
  }

  -- Leaves a local scope
  fun endScope () {
    makeCompEnv (nLabels, scopeDepth-1, leaveScope (state), nLocals, nArgs, functions)
  }

  -- Adds an argument for the current function
  fun addArg (name) {
    makeCompEnv (nLabels, scopeDepth, addName (state, name, Arg (nArgs)), nLocals, nArgs+1, functions)
  }

  -- Adds a local variable for the current function
  fun addVar (name) {
    if scopeDepth == 1
    then makeCompEnv (nLabels, scopeDepth, addName (state, name, Glb (name)), nLocals, nArgs, functions)
    else makeCompEnv (nLabels, scopeDepth, addName (state, name, Loc (nLocals)), nLocals+1, nArgs, functions)
    fi
  }

  -- Adds a binding for a function
  fun addFun (name, fLabel, nargs) {
    makeCompEnv (nLabels, scopeDepth, addName (state, name, Fun (fLabel, nargs)), nLocals, nArgs, functions)
  }
  
  -- Enters a function
  fun beginFun (state) {
    makeCompEnv (nLabels, 1, enterFunction (state), 0, 0, functions)
  }

  -- Get functions and empty functions list
  fun getFuns () {
    [functions, makeCompEnv (nLabels, scopeDepth, state, nArgs, nLocals, {})]
  }

  -- Lookups a name of a variable
  fun lookupVar (name) {
    case lookup (state, name) of
      Fun (_, _) -> error (sprintf ("the name ""%s"" does not designate a variable", name), getLoc (name))
    | x          -> x
    esac
  }

  -- Lookups a name of a function
  fun lookupFun (name) {
    case lookup (state, name) of
      x@Fun (_, _) -> x
    | _            -> error (sprintf ("the name ""%s"" does not designate a function", name), getLoc (name))
    esac
  }

  -- Gets the number of local variables
  fun getLocals () {
    nLocals
  }

  -- Generates an intrinsic function name
  fun genFunLabel (name) {
     if scopeDepth == 1
     then [sprintf ("L%s", name),             makeCompEnv (nLabels  , scopeDepth, state, nLocals, nArgs, functions)]
     else [sprintf ("L%s_%d", name, nLabels), makeCompEnv (nLabels+1, scopeDepth, state, nLocals, nArgs, functions)]
     fi 
  }

  -- Checks if the current scope is a global
  fun isGlobal () {
    scopeDepth == 1
  }
  
  [genLabel,
   rememberFun,
   beginScope,
   endScope,
   addArg,
   addVar,
   beginFun,
   getFuns,
   lookupVar,
   lookupFun,
   getLocals,
   genFunLabel,
   addFun,
   isGlobal
  ]
}

-- Initialize a new compilation environment
fun initCompEnv () {
  makeCompEnv (0, 0, emptyState (), 0, 0, {})
}

-- Accessor functions
fun genLabel (env) {
  env [0] ()
}

fun rememberFun (env, name, args, body) {
  env [1] (name, args, body)
}

fun beginScope (env) {
  env [2] ()
}

fun endScope (env) {
  env [3] ()
}

fun addArg (env, name) {
  env [4] (name)
}

fun addVar (env, name) {
  env [5] (name)
}

fun beginFun (env, state) {
  env [6] (state)
}

fun getFuns (env) {
  env [7] ()
}

fun lookupVar (env, name) {
  env [8] (name)
}

fun lookupFun (env, name) {
  env [9] (name)
}

fun getLocals (env) {
  env [10] ()
}

fun genFunLabel (env, name) {
  env [11] (name)
}

fun addFun (env, name, fLabel, nargs) {
  env [12] (name, fLabel, nargs)
}

fun isGlobal (env) {
  env [13] ()
}

-- Helper function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then singleton (env)
    else case genLabel (env) of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}

-- Helper function: adds a bunch of arguments
fun addArgs (env, names) {
  foldl (fun (env, name) {addArg (env, name)}, env, names)
}

-- Helper function: adds a bunch of locals
fun addVars (env, names) {
  foldl (fun (env, name) {addVar (env, name)}, env, names)
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.

(* Assignment *)

-- Some guidelines for compiling functions and scopes.
--
-- 1. use env.beginScope/env.endScope properly;
-- 2. in each scope traverse the definitions twice:
--    a. first, add all bindings into symbolic state,
--       using end.addVar/env.addFun;
--    b. do not forget to generate GLOBAL instructions for
--       top-level variable declarations;
--    c. on the secord traversal add functions themselves for
--       future code generation (use env.rememberFun).
-- 3. the overall flow for codegeneration:
--    a. generate the code for thetopmost expression (the progrman itself);
--    b. take list of nested functions definitions via env.getFuns and
--       generate the code for each function;
--    c. repeat b. until no function definitions appear.
-- 4. when compiling functions, do not forget to create proper
--    environment (use env.beginFun) and register arguments
--    (use env.addArg).

public fun compileSM (stmt) {
  case doCompileSM(initCompEnv(), stmt) of [env, commands] ->
    --printf("compileSM: %s\n", commands.string);
    commands
  esac
}

fun doCompileSM(env, stmt) {
  local pair, commands, functions;
  pair := compileFunction(env, "main", {}, stmt);
  env := pair[0];
  commands := pair[1];
  while (1) do
    if (size(functions) == 0) then
      case getFuns(env) of [functions1, env1] ->
        functions := functions1;
        env := env1
      esac
    fi;
    if (size(functions) == 0) then return [env, commands] fi;
    case functions of Fun (fLabel, args, body, state) : functions2 ->
      functions := functions2;
      env := beginFun(env, state);
      env := addArgs(env, args);
      case compileFunction(env, fLabel, args, body) of [env1, commands1] ->
        env := env1;
        commands := commands +++ commands1
      esac
    esac
  od
}

fun compileFunction(env, fLabel, args, body) {
  case compileSM1(env, body) of [env1, commands1] ->
    local commands;
    env := env1;
    commands := {LABEL (fLabel), BEGIN (fLabel, size(args), getLocals(env))} +++ commands1 +++ singleton(END);
    [env, commands]
  esac
}

fun compileSM1 (env, stmt) {
  local commands;
  --printf("compileSM1:        %s\n", env.string);
  --printf("compileSM1: %s\n", stmt.string);
  commands := case stmt of
    Scope (defs, expr) ->
      env := beginScope(env);
      case processDefs(env, defs) of [env1, commandsDefs] ->
        env := env1;
        case compileSM1(env, expr) of [env1, commandsExpr] ->
          env := env1;
          env := endScope(env);
          commandsDefs +++ commandsExpr
        esac
      esac
  | Call (name, args) ->
      local pair = foldl(fun([env, commands], arg) {
        case compileSM1(env, arg) of [env, commandsArg] ->
          [env, commands +++ commandsArg]
        esac
      }, [env, {}], args);
      case pair of [env1, commandsArgs] ->
        env := env1;
        case lookupFun(env, name) of Fun (fLabel, nargs) ->
          commandsArgs +++ singleton(CALL (fLabel, nargs))
        esac
      esac
  | Seq (stmt1, stmt2) ->
      case compileSM1(env, stmt1) of [env1, commands1] ->
        case compileSM1(env1, stmt2) of [env2, commands2] ->
          env := env2;
          commands1 +++ commands2
        esac
      esac
  | Skip -> {}
  | Var (var) -> singleton(LD (lookupVar(env, var)))
  | Ref (var) -> singleton(LDA (lookupVar(env, var)))
  | Const (value) -> singleton(CONST (value))
  | Ignore (expr) ->
      case compileSM1(env, expr) of [env1, commands] ->
        env := env1;
        commands +++ singleton(DROP)
      esac
  | Read (var) -> {READ, ST (lookupVar(env, var)), DROP}
  | Write (expr) ->
      case compileSM1(env, expr) of [env1, commands] ->
        env := env1;
        commands +++ singleton(WRITE)
      esac
  | Assn (var, expr) ->
      case compileSM1(env, var) of [env1, commands1] ->
        case compileSM1(env1, expr) of [env2, commands2] ->
          env := env2;
          commands1 +++ commands2 +++ singleton(STI)
        esac
      esac
  | If (expr, stmt1, stmt2) ->
      -- if expr == 0 jmp l1
      -- stmt1
      -- jmp l2
      -- l1
      -- stmt2
      -- l2
      case genLabels(env, 2) of [l1, l2, env2] ->
        case compileSM1(env2, expr) of [env3, commandsExpr] ->
          case compileSM1(env3, stmt1) of [env4, commandsStmt1] ->
            case compileSM1(env4, stmt2) of [env5, commandsStmt2] ->
              env := env5;
              commandsExpr +++ singleton(CJMP("z", l1)) +++ commandsStmt1 +++ {JMP(l2), LABEL(l1)} +++ commandsStmt2 +++ singleton(LABEL(l2))
            esac
          esac
        esac
      esac
  | While (expr, stmt) ->
      -- jmp l2
      -- l1
      -- stmt
      -- l2
      -- if expr != 0 jmp l1
      case genLabels(env, 2) of [l1, l2, env2] ->
        case compileSM1(env2, expr) of [env3, commandsExpr] ->
          case compileSM1(env3, stmt) of [env4, commandsStmt] ->
            env := env4;
            {JMP(l2), LABEL(l1)} +++ commandsStmt +++ singleton(LABEL(l2)) +++ commandsExpr +++ singleton(CJMP("nz", l1))
          esac
        esac
      esac
  | Repeat (stmt, expr) ->
      -- l1
      -- stmt
      -- if expr == 0 jmp l1
      case genLabel(env) of [l1, env2] ->
        case compileSM1(env2, expr) of [env3, commandsExpr] ->
          case compileSM1(env3, stmt) of [env4, commandsStmt] ->
            env := env4;
            singleton(LABEL(l1)) +++ commandsStmt +++ commandsExpr +++ singleton(CJMP("z", l1))
          esac
        esac
      esac
  | Binop (op, expr1, expr2) ->
      case compileSM1(env, expr1) of [env2, commands1] ->
        case compileSM1(env2, expr2) of [env3, commands2] ->
          commands1 +++ commands2 +++ singleton(BINOP (op))
        esac
      esac
  esac;
  return [env, commands]
}

fun processDefs(env, defs) {
  local commands;
  env := foldl(fun (env, def) {
    case def of
      Local (names) -> addVars(env, names)
    | Fun (name, args, body) ->
        case genFunLabel(env, name) of
          [fLabel, env] -> addFun(env, name, fLabel, size(args))
        esac
    esac
  }, env, defs);
  commands := if isGlobal(env) then
    flatten(map(fun(def) {
      case def of
        Local (names) -> map(fun(name) { GLOBAL (name) }, names)
      | Fun (name, args, body) -> {}
      esac
    }, defs))
  else
    {}
  fi;
  env := foldl(fun(env, def) {
    case def of
      Local (names) -> env
    | Fun (name, args, body) -> rememberFun(env, genFunLabel(env, name)[0], args, body)
    esac
  }, env, defs);
  [env, commands]
}

(* End *)
