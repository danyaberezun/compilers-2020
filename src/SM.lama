-- Stack machine.

import List;
import World;
import State;
import Expr;

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
-- Instruction = READ | WRITE | BINOP String | LD X | ST X | CONST N
fun eval (c, insns) {
  case c of
    [stack, state, world@[input, output]] -> case insns of
        {} -> c
      | Binop (b) : p -> case stack of x : y : ss -> eval ([binop_operations (b, y, x) : ss, state, world], p) esac
      | Const (n) : p -> eval ([n : stack, state, world], p)
      | Read      : p -> case input of x : it -> eval ([x : stack, state, [it, output]], p) esac
      | Write     : p -> case stack of x : ss -> eval ([ss, state, [input, x : output]], p) esac
      | LD    (x) : p -> eval ([state (x) : stack, state, world], p)
      | ST    (x) : p -> case stack of y : ss -> eval ([stack, (state <- [x, y]), world], p) esac
    esac
  esac

}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) {
   case expr of
     Var(x) -> singleton (LD (x)) 
    |Const(n) -> singleton (expr)
    |Binop(op, l, r) -> compileExpr(r) +++ compileExpr(l) +++ singleton(BINOP(op)) 
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  case stmt of
           Skip -> {} 
          | Assn(x, expr) -> {compileExpr(expr),singleton(ST(x))} 
          | Read(x) -> {singleton(READ), singleton(ST(x)} 
          | Write(expr) -> {compileExpr(expr), singleton(WRITE)}
          | Seq(s1, s2) -> {compileSM(s1), compileSM(s2)}
  esac
}
