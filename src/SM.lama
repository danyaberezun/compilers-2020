-- Stack machine.

import List;
import World;
import State;
import Expr;

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
-- Instruction = READ | WRITE | BINOP String | LD X | ST X | CONST N
fun eval (c@[stack, state, world], insns) {

  case insns of
    BINOP (op) : p -> case stack of a : b : rest -> eval([ binop_operations (op) (a, b) : rest, state, world ],p) esac

  | CONST (n)  : p -> eval( [n : stack, state, wrold], p )

  | READ       : p -> case readWorld (world) of [ a, world_ ] ->eval([ a : stack, state, world_ ],p) esac

  | WRITE      : p ->case stack of a : rest ->eval([ rest, state, writeWorld (a, world) ],p) esac

  | LD    (x)  : p -> eval( [state(x) : stack, state, world], p)

  | ST    (x)  : p -> case stack of a : rest ->eval([ rest, state <- [ x, a ], world ],p) esac

  | {} -> c
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) {
   case expr of
     Var(x) -> singleton (LD (x)) 
    |Const(n) -> singleton (expr)
    |Binop(op, l, r) -> compileExpr(r) +++ compileExpr(l) +++ singleton(BINOP(op)) 
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  case stmt of
           Skip -> {} 
          | Assn(x, expr) -> {compileExpr(expr),singleton(ST(x))} 
          | Read(x) -> {singleton(READ), singleton(ST(x)} 
          | Write(eexpr) -> {compileExpr(expr), singleton(WRITE)}
          | Seq(s1, s2) -> {compileSM(s1), compileSM(s2)}
  esac
}
