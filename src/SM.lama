

import List;
import World;
import State;
import Expr;
import Util;


fun eval (c, insns) {
  case c of
    [stack, state, world@[input, output]] -> case insns of
        {} -> c
      | Binop (b) : p -> case stack of x : y : ss -> eval ([binopOperations (b, y, x) : ss, state, world], p) esac
      | Const (n) : p -> eval ([n : stack, state, world], p)
      | Read      : p -> case input of x : it -> eval ([x : stack, state, [it, output]], p) esac
      | Write     : p -> case stack of x : ss -> eval ([ss, state, [input, x : output]], p) esac
      | LD    (x) : p -> eval ([state (x) : stack, state, world], p)
      | ST    (x) : p -> case stack of y : ss -> eval ([stack, (state <- [x, y]), world], p) esac
    esac
  esac

}

public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

fun compileExpr (expr) {
   case expr of
     Var(x) -> singleton (LD (x)) 
    |Const(n) -> singleton (expr)
    |Binop(op, l, r) -> compileExpr(r) +++ compileExpr(l) +++ singleton(Binop(op)) 
  esac
}

public fun compileSM (stmt) {
  case stmt of
            Assn (x, expr) -> compileExpr (expr) +++ singleton (ST (x))
          | Seq (s1, s2)   -> compileSM (s1) +++ compileSM (s2) 
          | Skip -> {} 
          | Read (x)       -> {Read, ST (x)} 
          | Write (expr)   -> compileExpr (expr) +++ singleton (Write)
          
  esac
}
