-- Stack machine.

import List;
import World;
import State;
import Expr;
import Util;

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c, insns) {
  failure ("SM eval not implemented\n")
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) {
  --failure ("compileExpr not implemented\n")
  case expr of
     Var(x) -> singleton(LD(x))
    |Const(n) -> singleton(CONST(x))
    |Binop (op, lft, rght) -> compileExpr(lft) +++ compileExpr(rght) +++ singleton(BINOP(op))
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  --failure ("compileSM not implemented\n")
  case stmt of
     Assn(x, expr) -> compileExpr(expr) +++ singleton(ST(x))
    |Read(x) -> Read +++ ST(x)
    |Write(expr) -> compileExpr(expr) +++ singleton(Write)
    |Seq(s1,s2) ->compileSM(s1) +++ compileSM(s2)
    |Skip -> {}
  esac
}
