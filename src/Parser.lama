-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}


-- Primary expression
local primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                   x=lident  {Var (x)}               |
                                   inbr[s("("), exp, s(")")]),
      binOps = fun (l, op, r) {Binop (op, l, r)},
      priorityTable = {[Left, [s ("!!"), binOps] : {}],
             [Left, [s ("&&"), binOps] : {}],
             [Nona, [s ("<") | s (">") | s ("<=") | s (">=") | s ("==") | s ("!="), binOps] : {}],
             [Left, [s ("+") | s ("-"), binOps] : {}],
             [Left, [s ("*") | s ("/") | s ("%"), binOps] : {}]},
      exp = memo $ eta expr (priorityTable, primary);
      
local parseElse =  memo $ eta syntax (
      -kElse stSeq -kFi |
      -kFi   {Skip}     |
      -kElif cond=exp kThen st=stSeq elsePart=parseElse {If(cond, st, elsePart)}
);
  
local stSeq = memo $ eta syntax (stmt | x1=stmt s[";"] x2=stSeq {Seq(x1, x2)});

local stmt = memo $ eta syntax (
      kSkip                                                                          {Skip}                                |
      kWrite    x=inbr[s("("), exp, s(")")]                                          {Write (x)}                           |
      kRead     x=inbr[s("("), lident, s(")")]                                       {Read (x)}                            |
      x=lident  s[":="]  y=exp                                                       {Assn (x, y)}                         |
      x1=stmt   s[";"]   x2=stmt end                                                 {Seq (x1, x2)}                        |
      kWhile    cond=exp st=inbr[kDo, stSeq, kOd]                                    {While (cond, st)}                    |
      kRepeat   st=stSeq  kUntil cond=exp                                            {Repeat (st, cond)}                   |
      kFor      x1=stSeq  s[","] cond=exp s[","] x2=stSeq body=inbr[kDo, stSeq, kOd] {Seq(x1, While(cond, Seq(body, x2)))} |
      kIf cond=exp kThen st=stSeq elsePart=parseElse {If(cond, st, elsePart)}
);

-- Public top-level parser
public parse = stmt;