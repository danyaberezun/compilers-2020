-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
local primary = memo $ eta syntax (x = decimal {Const (stringInt (x))} |
                                   x = lident  {Var (x)}               |
                                   inbr[s("("), exp, s(")")]
                                  );
                               
      	                                    
local exp = memo $ eta expr(
	     {[Left, [s ("!!"), fun (l, op, r) {Binop (op, l, r)}] : {}],
      	     [Left, [s ("&&"), fun (l, op, r) {Binop (op, l, r)}] : {}],
      	     [Nona, [s ("<") | s (">") | s ("<=") | s (">=") | s ("==") | s ("!="), fun (l, op, r) {Binop (op, l, r)}] : {}],
      	     [Left, [s ("+") | s ("-"), fun (l, op, r) {Binop (op, l, r)}] : {}],
      	     [Left, [s ("*") | s ("/") | s ("%"), fun (l, op, r) {Binop (op, l, r)}] : {}]
      	     }, primary);
      			
local simpleStmt = memo $ eta syntax (
	kSkip {Skip} |
	kRead x = inbr[s("("), lident, s(")")] {Read(x)} |
	kWrite e = inbr[s("("), exp, s(")")] {Write(e)} | 
	x = lident s[":="] e = exp {Assn(x, e)}
	);
      
local stmt = memo $ eta syntax(simpleStmt |
	s1 = stmt s[";"] s2 = stmt end {Seq(s1, s2)});

-- Public top-level parser
public parse = stmt;
