-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
<<<<<<< HEAD

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
=======
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
>>>>>>> A01-straight-line-int-sm
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
<<<<<<< HEAD
local primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                   x=lident {Var (x)}               |
                                   inbr[s("("), exp, s(")")]),
      binopop = fun (l, op, r) {Binop (op, l, r)},
      ops = {[Left, [s ("!!"), binopop] : {}],
             [Left, [s ("&&"), binopop] : {}],
             [Nona, [s ("<") | s (">") | s ("<=") | s (">=") | s ("==") | s ("!="), binopop] : {}],
             [Left, [s ("+") | s ("-"), binopop] : {}],
             [Left, [s ("*") | s ("/") | s ("%"), binopop] : {}]},
      exp = memo $ eta expr (ops, primary) (id);

local stmt = memo $ eta syntax (
  kWrite x=inbr[s("("), exp, s(")")]    {Write (x)}   |
  kRead  x=inbr[s("("), lident, s(")")] {Read (x)}    |
  x=lident s[":="] y=exp                {Assn (x, y)} |
  x1=stmt s[";"] x2=stmt end            {Seq (x1, x2)}
);
  

-- Public top-level parser
public parse = stmt;
             
=======
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident  @ fun (x) {Var (x)} |
                            inbr (s ("("), exp, s (")"))),
      exp = memo $ eta (failure ("expression parsing not implemented\n"));

local stmt = memo $ eta (failure ("statement parsing not implemented\n"));
   

-- Public top-level parser
public parse = stmt;
>>>>>>> A01-straight-line-int-sm
