-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
local primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} 
								 | x=lident  {Var (x)}               
								 | inbr[s("("), exp, s(")")]),
                                   
		exp = memo $ eta expr ({	[Left, [s("!!"), fun(l, op, r) {Binop(op, l, r)} ]:{}],
				                    [Left, [s("&&"), fun(l, op, r) {Binop(op, l, r)} ]:{}],
									[Nona, { [s("=="), fun(l, op, r) {Binop(op, l, r)}],
											 [s("!="), fun l, op, r) {Binop(op, l, r)}],
											 [s("<="), fun(l, op, r) {Binop(op, l, r)}],
											 [s("<"), fun l, op, r) {Binop(op, l, r)}],
											 [s(">="), fun(l, op, r) {Binop(op, l, r)}],
											 [s(">"), fun(l, op, r) {Binop(op, l, r)}] }],
									[Left, { [s("+"), fun(l, op, r) {Binop(op, l, r)}],
				      						 [s("-"), fun(l, op, r) {Binop(op, l, r)}] }],
							  	    [Left, { [s("*"), fun(l, op, r) {Binop(op, l, r)}],
					 						 [s("/"), fun(l, op, r) {Binop(op, l, r)}],
					         				 [s("%"), fun(l, op, r) {Binop(op, l, r)}] 
								}] }, primary);
  
binOps = fun(l, op, r) {Binop(op, l, r)},
      ops = {
			 [Left, [s("!!"), binOps] : {}],
			 [Left, [s("&&"), binOps] : {}],
		   	 [Nona, [s("<") | s (">") | s("<=") | s(">=") | s("==") | s("!="), binOps] : {}],
			 [Left, [s("+") | s("-"), binOps] : {}],
			 [Left, [s("*") | s("/") | s("%"), binOps] : {}]
		},

      exp = memo $ eta expr (ops, primary) ;    

local stmt = memo $ eta syntax (
			kRead x=inbr[s("("), lident, s(")")] {Read (x)} |
			kWrite e=inbr[s("("), exp, s(")")] {Write(expr)} |
			x=lident s[":="] e=exp {Assn(st, expr)} |
			s1=stmt s[";"] s2=stmt end {Seq(stmt1, stmt2)} |
			kSkip {Skip}  
			);
   

-- Public top-level parser
public parse = stmt;
             
