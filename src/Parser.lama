-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, val, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (val)
  | _    -> val
  esac
}

fun assertVoid (atr, val, loc) {
  case atr of
    Void -> val
  | Val  -> error ("value expected", loc)
  | _    -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
                          fun (a) {
                            assertValue (a, Binop (op, l (Val), r (Val)), loc)
                          }
                        }
  ]
}

local primary  = memo $ eta syntax (
          -- decimal constant
          loc=pos x=decimal {
            fun (a) {assertValue (a, Const (stringInt (x)), loc)}
          } |

          -- identifier
          x=lident {
            fun (a) { case a of
                        Ref  -> Ref (x)
                      | Void -> Ignore (Var (x))
                      | _    -> Var (x)
                      esac }
          } |

          -- skip
          kSkip { 
            fun(a) { assertVoid(a, Skip, loc) } 
          } |

          -- read
          loc=pos kRead x=inbr[s("("), lident, s(")")] {
            fun(a) { assertVoid(a, Read(x), loc) }
          } |

          -- write
          loc=pos kWrite x=inbr[s("("), exp, s(")")] {
            fun(a) { assertVoid(a, Write(x(Val)), loc) } 
          } |

          -- while
          loc=pos kWhile ex=exp body=inbr[kDo, exp, kOd] {
            fun(a) { assertVoid(a, While(ex(Val), body(Void)), loc) } 
          } |

          -- repeat until
          loc=pos kRepeat body=exp kUntil cond=inbr[s("("),exp,s(")")] {
            fun(a) { assertVoid(a, Repeat(body(Void), cond(Val)), loc) } 
          } |

          -- for
          loc=pos -kFor init=exp s[","] cond=exp s[","] step=exp -kDo body=exp -kOd { 
            fun(a) { assertVoid(a, Seq( init(a), While(cond(Val), Seq(body(Void), step(Void))) ), loc) } 
          } |
          
          -- if - then - else 
          -kIf ifParser |

          inbr[s("("), exp, s(")")]
          ),


      elseParser = memo $ eta syntax ( 
          -kElse e=exp -kFi | 
          -kElif ifParser   |
          loc=pos empty -kFi { 
            fun(a) { assertVoid(a, Skip, loc) } 
          }),


      ifParser = memo $ eta syntax ( 
          loc=pos ex=exp -kThen s1=exp else_part=elseParser {
            fun(a) { If (ex(Val), s1(a), else_part(a)) } 
          }),


      basic    = memo $ eta (expr (
          {[Right, singleton ([s (":="),
                              fun (l, loc, r) {
                                fun (a) {assertValue (a, Assn (l (Ref), r (Val)), loc)}
                              }])],
          [Left , map (binop, singleton ("!!"))],
          [Left , map (binop, singleton ("&&"))],
          [Nona , map (binop, {"==", "!=", "<", ">", "<=", ">="})],
          [Left , map (binop, {"+", "-"})],
          [Left , map (binop, {"*", "/", "%"})]
          },
          primary)),


      exp      = memo $ eta syntax (basic | s1=basic s[";"] s2=exp {fun (a) {Seq (s1 (Void), s2 (a))}});


-- Public top-level parser
public parse = syntax (s=exp {s (Void)});
