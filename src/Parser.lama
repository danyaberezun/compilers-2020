-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun createBinop(l, op, r) {
  Binop(op, l, r)
}

-- Primary expression
local primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                   x=lident  {Var (x)}               |
                                   inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr(
  {
    [Left,
      [s("!!"), createBinop]:{}
    ],
    [Left, 
      [s("&&"), createBinop]:{}
    ],
    [Nona, {
      [s("=="), createBinop],
      [s("!="), createBinop],
      [s("<="), createBinop],
      [s(">="), createBinop],
      [s("<"), createBinop],
      [s(">"), createBinop]
    }
    ],
    [Left, {
      [s("+"), createBinop],
      [s("-"), createBinop]
    }
    ],
    [Left, {
      [s("*"), createBinop],
      [s("/"), createBinop],
      [s("%"), createBinop]
    }
    ]
  }, primary
)(id);

local stmt = memo $ eta syntax (
  kRead x=inbr[s("("), lident, s(")")] { Read(x) } |
  kWrite e=inbr[s("("), exp, s(")")] { Write(e) } |
  x=lident s[":="] e=exp {Assn(x, e)} |
  stmt1=stmt s[";"] stmt2=stmt end {Seq(stmt1, stmt2)} |
  kSkip {Skip}
);
   

-- Public top-level parser
public parse = stmt;
             
