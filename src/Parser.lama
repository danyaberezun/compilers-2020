-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"


-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"

fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression

local primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                   x=lident  {Var (x)}               |
                                   inbr[s("("), exp, s(")")]),
      
      apply = fun (l, op, r) {Binop(op, l, r)},
      
      ops = {
              [Left, [s("!!"), apply] : {}],
              [Left, [s("&&"), apply] : {}],
              [Nona, [s("<") | s(">") | s(">=") | s("<=") | s("==") | s("!="), apply] : {}],
              [Left, [s("+") | s("-"), apply] : {}],
              [Left, [s("*") | s("/") | s("%"), apply] : {}]
            },
      
      exp = memo $ eta expr(ops, primary);

local stmt = memo $ eta syntax(
  
        kWrite x = inbr[s("("), exp, s(")")]             {Write(x)}    |
        
        kRead x = inbr[s("("), lident, s(")")]           {Read(x)}     |
        
        x = lident s[":="] y = exp                       {Assn(x, y)}  | 
        
        x = stmt s[";"] y = stmt end                     {Seq(x, y)}   |
        
        kSkip                                            {Skip}        |

        kIf cond=exp kThen s1=seqq s2=ifTailParser       {If (cond, s1, s2)} |
        
        kWhile cond=exp kDo s=seqq kOd                   {While(cond, s)} |

        kRepeat s=seqq kUntil cond=exp                   {Repeat(s, cond)} |

        kFor e1=seqq s[","] e2=exp s[","] e3=seqq kDo s=seqq kOd {Seq(e1, While(e2, Seq(s, e3)))}
        ),

      ifTailParser = memo $ eta syntax (-kFi                   {Skip} |
                                          
                                        -kElse seqq -kFi              |
                                          
                                        kElif cond=exp kThen s1=seqq s2=ifTailParser {If(cond, s1, s2)}
      ),

      seqq = memo $ eta syntax (stmt | s1=stmt s[";"] s2=seqq {Seq(s1, s2)}
      );
      

-- Public top-level parser
public parse = stmt;

