-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
local primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                   x=lident  {Var (x)}               |
                                   inbr[s("("), exp, s(")")]),
      exp = memo $ eta (expr(binaryOperators, primary));

local binaryOperators = asBinopLevelDescriptor.map(
  {[Left, singleton ("!!")],
   [Left, singleton ("&&")],
   [Nona, {"==", "!=", "<", "<=", ">=", ">"}],
   [Left, {"+", "-"}],
   [Left, {"*", "/", "%"}]}
);

fun asBinopLevelDescriptor([assoc, operatorList]) {
  [assoc, map (fun (op) { [s(op), binop] }, operatorList)]
}

fun binop (l, op, r) {
  Binop (op, l, r)
}

local stmt = memo $ eta (seqParser |> bypass(end));

local assnParser = memo $ eta syntax (name=lident s[":="] value=exp {Assn (name, value)}),
      readParser = memo $ eta syntax (kRead s["("] name=lident s[")"] {Read (name)}),
      writeParser = memo $ eta syntax (kWrite s["("] value=exp s[")"] {Write (value)}),
      skipParser = memo $ eta syntax (kSkip {Skip}),
      singleStatementParser = memo $ eta (assnParser | readParser | writeParser | skipParser),
      seqParser = memo $ eta syntax (stmt=singleStatementParser s[";"] tail=seqParser {Seq (stmt, tail)} |
                                     singleStatementParser);

-- Public top-level parser
public parse = stmt;
