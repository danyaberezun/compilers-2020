-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
local primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                   x=lident  {Var (x)}               |
                                   inbr[s("("), exp, s(")")]);

-- return S-expr "Binop" for evalExpr from Expr.lama
local rBinop = fun(l, op, r) {Binop(op, l, r)};

-- Operators
local ops = { 
              [Left, [s("!!"), rBinop] : {}],
              [Left, [s("&&"), rBinop] : {}],
              [Nona, [s("<") | s(">") | s("<=") | s(">=") | s("==") | s("!="), rBinop] : {}],
              [Left, [s("+") | s("-"), rBinop] : {}],
              [Left, [s("*") | s("/") | s("%"), rBinop] : {}]
            };

-- Expression parser (operators + primary operands)
local exp = memo $ eta expr(ops, primary);

-- Statement parser
local stmt = memo $ eta syntax ( kRead  x=inbr[s("("), lident, s(")")] {Read(x)}    |
                                 kWrite e=inbr[s("("), exp, s(")")]    {Write(e)}   |
                                 x=lident s[":="] e=exp                {Assn(x, e)} |
                                 s1=stmt s[";"] s2=stmt end            {Seq(s1, s2)}|
                                 kSkip {Skip});
                                 
-- Public top-level parser
public parse = stmt;
             
