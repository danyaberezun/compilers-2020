-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- flip Binop
fun binop(lhs, op, rhs) {
  Binop (op, lhs, rhs)
}

local opTable = {
  [Left, [s ("!!"), binop] : {}],
  [Left, [s ("&&"), binop] : {}],
  [Nona, [s ("==") | s ("!=") | s ("<") | s ("<=") | s (">") | s (">="), binop] : {}],
  [Left, [s ("+") | s ("-"), binop] : {}],
  [Left, [s ("*") | s ("/") | s ("%"), binop] : {}]
};

-- Primary expression
local primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                   x=lident  {Var (x)}               |
                                   inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (opTable, primary);

local block = memo $ eta syntax (
  x=stmt s[";"]
  y=block
  { Seq (x, y) } | stmt
);

local ifElif = memo $ eta syntax (
  x=exp kThen
  body1=block
  body2=(
    -kElse block -kFi |
    -kElif ifElif |
    kFi {Skip}
  )
  { If (x, body1, body2) }
);

local stmt = memo $ eta syntax (
  x=kSkip {Skip} |
  x=lident s[":="] y=exp {Assn (x, y)} |
  kRead x=inbr[s("("), lident, s(")")] {Read (x)} |
  kWrite x=inbr[s("("), exp, s(")")] {Write (x)} |
  kWhile x=exp kDo y=block kOd { While (x, y) } |
  kFor init=stmt s[","] cond=exp s[","] incr=stmt kDo body=block kOd { Seq (init, While (cond, Seq (body, incr))) } |
  kRepeat body=block kUntil cond=exp { Repeat (body, cond) } |
  -kIf ifElif
);


-- Public top-level parser
public parse = block;

