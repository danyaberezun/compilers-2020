-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
local primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                   x=lident  {Var (x)}               |
                                   inbr[s("("), exp, s(")")]),
      product = memo $ eta syntax (
        primary |
        l=product op=(s["*"] | s["/"] | s["%"]) r=primary {Binop (op, l, r)}
      ),
      sum = memo $ eta syntax (
        product |
        l=sum op=(s["+"] | s["-"]) r=product {Binop (op, l, r)}
      ),
      comp = memo $ eta syntax (
        sum |
        l=sum op=(s["<"] | s[">"] | s["=="] | s["!="] | s["<="] | s[">="]) r=sum
          {Binop(op, l, r)}
      ),
      conj = memo $ eta syntax (
        comp |
        l=conj op=s["&&"] r=comp {Binop (op, l, r)}
      ),
      disj = memo $ eta syntax (
        conj |
        l=disj op=s["!!"] r=conj {Binop (op, l, r)}
      ),
      exp = memo $ eta syntax (
        disj
      );

local 
      elseBranch = memo $ eta syntax (
        -kElse stmt -kFi |
        kElif cond=exp kThen s1=stmt s2=elseBranch {If (cond, s1, s2)}
      ),
      primaryStmt = memo $ eta syntax (
        kSkip {Skip} |
        kRead x=inbr[s("("), lident, s(")")] {Read (x)} |
        kWrite e=inbr[s("("), exp, s(")")] {Write (e)} |
        x=lident s[":="] e=exp {Assn (x, e)} |
        kIf cond=exp kThen st=stmt kFi {If (cond, st, Skip)} |
        kIf cond=exp kThen s1=stmt s2=elseBranch {If (cond, s1, s2)} |
        kWhile cond=exp kDo st=stmt kOd {While (cond, st)} |
        kRepeat st=stmt kUntil cond=exp {Repeat (st, cond)} |
        kFor init=stmt s[","] cond=exp s[","] step=stmt kDo st=stmt kOd
          {Seq (init, While (cond, Seq (st, step)))}
      ),
      stmt = memo $ eta syntax (
        primaryStmt |
        s1=primaryStmt s[";"] s2=stmt {Seq (s1, s2)}
      );
   

-- Public top-level parser
public parse = stmt;