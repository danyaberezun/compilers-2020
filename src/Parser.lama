-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun toOpParser(ops, assoc) {
  fun binop(l, op, r) { Binop(op, l, r) }
  [assoc, map (fun (op) {[s(op), binop]}, ops)]
}

local ops = {
    ("!!":{}).toOpParser(Left),
    ("&&":{}).toOpParser(Left),
    {"<", "<=", "==", "!=", ">=", ">"}.toOpParser(Nona),
    {"+", "-"}.toOpParser(Left),
    {"*", "/", "%"}.toOpParser(Left)
};

-- Primary expression
local primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                   x=lident  {Var (x)}               |
                                   inbr[s("("), exp, s(")")]),
                exp = memo $ eta expr (ops, primary);

local singleStmt = memo $ eta syntax  ( kSkip                                   {   Skip             }         
                                      | x=lident s[":="] e=exp                  {   Assn (x, e)      } 
                                      | kRead  x=inbr[s("("), lident, s(")")]   {   Read (x)         } 
                                      | kWrite e=inbr[s("("), exp,    s(")")]   {  Write (e)         } 
                                      | kWhile e=exp kDo st=stmt kOd            {  While (e, st)     }
                                      | kIf e=exp kThen s1=stmt s2=elseStmt kFi {     If (e, s1, s2) }
                                      | kRepeat s=stmt kUntil e=exp             { Repeat (s, e)      }
                                      | kFor s1=stmt s[","] 
                                             e=exp   s[","] 
                                             s2=stmt        kDo s3=stmt kOd     { Seq (s1, While (e, Seq (s3, s2))) }
                                      ),
      elseStmt = memo $ eta syntax ( kElif e=exp kThen s1=stmt s2=elseStmt {   If (e, s1, s2) }
                                   | kElse s=stmt                          {    s             }
                                   | empty                                 { Skip             }
                                   ),
      stmt = memo $ eta syntax (x=singleStmt s[";"] y=stmt {Seq (x, y)} | singleStmt);

-- Public top-level parser
public parse = stmt;
