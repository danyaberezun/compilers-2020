-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun toOpParser(ops, assoc) {
  fun binop(l, op, r) { Binop(op, l, r) }
  [assoc, map (fun (op) {[s(op), binop]}, ops)]
}

local ops = {
    ("!!":{}).toOpParser(Left),
    ("&&":{}).toOpParser(Left),
    {"<", "<=", "==", "!=", ">=", ">"}.toOpParser(Nona),
    {"+", "-"}.toOpParser(Left),
    {"*", "/", "%"}.toOpParser(Left)
};



-- Primary expression
local primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                   x=lident  {Var (x)}               |
                                   inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (ops, primary) (id);


local singleStmt = memo $ eta syntax  ( kSkip                                 { Skip         }         

                                      | x=lident s[":="] e=exp                { Assn  (x, e) } 
                                      | kRead  x=inbr[s("("), lident, s(")")] { Read  (x)    } 
                                      | kWrite e=inbr[s("("), exp,    s(")")] { Write (e)    } 
                                      ),
      stmt = memo $ eta syntax (x=singleStmt s[";"] y=stmt {Seq (x, y)} | singleStmt);




--local stmt = memo $ eta (failure ("statement parsing not implemented\n"));
   

-- Public top-level parser
public parse = stmt;
