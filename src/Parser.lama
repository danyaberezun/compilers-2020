-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun createBinop(l, op, r) {
  Binop(op, l, r)
}

-- Primary expression
local primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                   x=lident  {Var (x)}               |
                                   inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr(
  {
    [Left,
      [s("!!"), createBinop]:{}
    ],
    [Left, 
      [s("&&"), createBinop]:{}
    ],
    [Nona, {
      [s("=="), createBinop],
      [s("!="), createBinop],
      [s("<="), createBinop],
      [s(">="), createBinop],
      [s("<"), createBinop],
      [s(">"), createBinop]
    }
    ],
    [Left, {
      [s("+"), createBinop],
      [s("-"), createBinop]
    }
    ],
    [Left, {
      [s("*"), createBinop],
      [s("/"), createBinop],
      [s("%"), createBinop]
    }
    ]
  }, primary
);

local elifStmt = syntax (
  kElif e=exp kThen s=stmt ot=elifStmt? {If(e, s, ot)} |
  kElse s=stmt { s }
);

local sstmt = memo $ eta syntax (
  kRead x=inbr[s("("), lident, s(")")] { Read(x) } |
  kWrite e=inbr[s("("), exp, s(")")] { Write(e) } |
  x=lident s[":="] e=exp {Assn(x, e)} |
  kSkip {Skip} |
  
  kIf c=exp kThen s=stmt ot=elifStmt? kFi {If(c, s, ot)} |
  kWhile c=exp kDo s=stmt kOd {While(c, s)} |
  kFor i=stmt s[","] c=exp s[","] s=stmt kDo ot=stmt kOd {Seq(i, While(c, Seq(ot, s)))} |
  kRepeat s=stmt kUntil c=exp { Rep(s, c) }
);

local stmt = memo $ eta syntax (
  sstmt |
  stmt1=sstmt s[";"] stmt2=stmt {Seq(stmt1, stmt2)}
);
   

-- Public top-level parser
public parse = syntax(stmt -end);
