-- Parser 
import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"

fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
local primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                          x=lident  {Var (x)}                        |
                          inbr[s("("), exp, s(")")]);
                          local exp = memo $ eta expr ({[Left, [s ("!!"), fun (l, op, r) {Binop (op, l, r)}] : {}],
                                      		       [Left, [s ("&&"), fun (l, op, r) {Binop (op, l, r)}] : {}],
                                        		       [Nona, [s ("<") | s (">") | s (">=") | s ("<=") | s ("==") | s ("!="), fun (l, op, r) {Binop (op, l, r)}] : {}],
                                      		       [Left, [s ("+") | s ("-"), fun (l, op, r) {Binop (op, l, r)}] : {}],
                                       		       [Left, [s ("*") | s ("/") | s ("%"), fun (l, op, r) {Binop (op, l, r)}] : {}]}
                                       		       , primary);
local stmtSeq = memo $ eta syntax (simpleStmt | x1=simpleStmt s[";"] x2=stmtSeq {Seq(x1, x2)});
                            local simpleStmt = memo $ eta syntax (
                            kSkip {Skip}                                                                                                          |
                                   kRead x=inbr[s("("), lident, s(")")] {Read (x)}                                                                       |
                                   kWrite x=inbr[s("("), exp, s(")")] {Write (x)}                                                                        |
                                   x=lident s[":="] y=exp {Assn (x, y)}                                                                                  |
                                   s1=simpleStmt s[";"]   s2=simpleStmt end {Seq (s1, s2)}                                                               |
                                   kWhile cond=exp st=inbr[kDo, stmtSeq, kOd] {While (cond, st)}                                                         |
                                   kFor s1=stmtSeq  s[","] cond=exp s[","] s2=stmtSeq body=inbr[kDo, stmtSeq, kOd] {Seq(s1, While(cond, Seq(body, s2)))} |
                                   kRepeat s1=stmtSeq  kUntil cond=exp {Repeat (s1, cond)}                                                               |
                                   kIf cond=exp kThen s1=stmtSeq elsePart=parseElse {If(cond, s1, elsePart)}
                             );

                              local parseElse =  memo $ eta syntax (
                                   -kElse stmtSeq -kFi |
                                   -kElif cond=exp kThen st=stmtSeq elsePart=parseElse {If(cond, st, elsePart)} |
                                   -kFi   {Skip}

                              );
public parse = simpleStmt;
