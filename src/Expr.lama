-- Expression evaluator

import List;
import State;
import World;
import Lexer;
import Parser;

-- As association map which maps "\otimes" into "\oplus"
local ops = {
  ["+" , infix + ],
  ["-" , infix - ],
  ["*" , infix * ],
  ["/" , infix / ],
  ["%" , infix % ],
  ["==", infix ==],
  ["!=", infix !=],
  ["<" , infix < ],
  ["<=", infix <=],
  [">" , infix > ],
  [">=", infix >=],
  ["&&", infix &&],
  ["!!", infix !!]
};

-- The evaluator for infix operators: takes an operator as a string
-- and two operand values, and returns the result
public fun evalOp (op, l, r) {
  case assoc (ops, op) of
    Some (f) -> f (l, r)
  esac
}

-- Evaluates an expression "expr" in a configuration "c".
-- A configuration is a pair of a state "s" and a world "w".
-- Returns a final configuration (if any)
--
-- A expression is represented by a data structure of the following shape:
--
-- expr = Assn   (string, expr)       |
--        Seq    (expr, expr)         |
--        Skip                        |
--        Read   (string)             |
--        Write  (expr)               |
--        if     (expr, expr, expr)   |
--        While  (expr, expr)         |
--        Repeat (expr, expr)         |
--        Var    (string)             |
--        Ref    (string)             |
--        Const  (int)                |
--        Binop  (string, expr, expr) |
--        Scope  (def list, expr)     |
--        Call   (string, expr list)  |
--        Ignore (expr)
--
-- A definition is either a local variable definition or a function
-- definition:
--
-- def = Local (string list)                |
--       Fun   (string, string list, expr)

-- Helper function: checks that given name designates a regular variable in
-- a given state
fun checkVar (state, name) {
  case state.lookup (name) of
    Var (_) -> skip
  | _       -> error (sprintf ("the name ""%s"" does not designate a variable", name), getLoc (name))
  esac
}

-- Helper function: checks that given name designates a function in
-- a given state
fun checkFun (state, name) {
  case state.lookup (name) of
    Fun (_, _) -> skip
  | _          -> error (sprintf ("the name ""%s"" does not designate a function", name), getLoc (name))
  esac
}

-- Helper function: adds a bunch of regular variables current scope
fun addNames (state, names) {
  foldl (fun (s, name) {s.addName (name, Var (0))}, state, names)
}

-- Helper function: adds a function in current scope
fun addFunction (state, name, args, body) {
  state.addName (name, Fun (args, body))
}

-- Evaluates a list of expressions, properly threading a configurations.
-- Returns the final configuration and the list of values
fun evalList (c, exprs) {
  case foldl (fun ([c, vals], e) {
                case eval (c, e) of
                  [c, val] -> [c, val : vals]
                esac
              },
              [c, {}],
              exprs) of
    [c, vals] -> [c, reverse (vals)]
  esac
}

fun evalDef (configuration@[state, world], def) {
  case def of
    Local (names) -> [addNames(state, names), world]
  | Fun (name, args, body) -> [addFunction(state, name, args, body), world]
  esac
}
fun evalDefsList (c, defs) {
  foldl (evalDef, c, defs)
}

-- не уверен что это правильно
local void = "void";

fun eval (configuration, expr) {
  eval0(configuration, expr)
}

fun eval1 (configuration, expr) {
  printf("eval: %s\n", expr.string);
  printf("eval: %s\n", configuration.string);
  case eval0(configuration, expr) of [configuration, value] ->
    printf("\teval: %s  =>  %s\n", expr.string, value.string);
    [configuration, value]
  esac
}

fun eval0 (configuration@[state, world], expr) {
  case expr of
    Scope (defs, expr) ->
      configuration := evalDefsList([enterScope(state), world], defs);
      case eval(configuration, expr) of
        [[state, world], result] -> [[leaveScope(state), world], result]
      esac
  | Seq (stmt1, stmt2) -> return eval(eval(configuration, stmt1)[0], stmt2)
  | Call (name, exprs) -> {
    checkFun(state, name);
    case lookup(state, name) of Fun (args, body) ->
      case evalList(configuration, exprs) of [[state, world], values] ->
        -- не знаю как писать циклы в Lama...
        -- for (value in values) { checkVar(state, value); }

        local state1 = state;
        state := enterFunction(state);
        state := foldl(fun(state, [arg, value]) {
          addName(state, arg, Var (value))
        }, state, zip(args, values));

        case eval([state, world], body) of [[state, world], result] ->
          [[leaveFunction(state1, getGlobal(state)), world], result]
        esac
      esac
    esac
  }
  | Skip -> [configuration, void]
  | Ref (x) ->
      checkVar(state, x);
      [configuration, Ref (x)]
  | Ignore (expr) ->
      case eval(configuration, expr)
        of [configuration, _] -> [configuration, void]
      esac
  | Read (var) ->
      checkVar(state, var);
      case readWorld (world) of [value, world] ->
        state := state <- [var, Var (value)];
        return [[state, world], void]
      esac
  | Write (expr) ->
      case eval(configuration, expr) of [[state, world], value] ->
        world := writeWorld(value, world);
        return [[state, world], void]
      esac
  | Assn (dst, expr) ->
      case evalList(configuration, {dst, expr}) of [[state, world], {Ref (var), value}] ->
        checkVar(state, var);
        state := state <- [var, Var (value)];
        return [[state, world], value]
      esac
  | If (expr, stmtThen, stmtElse) ->
      case eval(configuration, expr) of [configuration, value] ->
        return eval(configuration, if value then stmtThen else stmtElse fi)
      esac
  | While (expr, stmt) ->
      return evalWhile(expr, stmt, fun (value) { value != 0 }, configuration)
  | Repeat (stmt, expr) ->
      case eval(configuration, stmt) of [configuration, _] ->
        return evalWhile(expr, stmt, fun (value) { value == 0 }, configuration)
      esac

  | Var (var) -> {
    checkVar(state, var);
    case lookup(state, var) of
      Var (value) -> [configuration, value]
    esac
  }
  | Const (value) -> return [configuration, value]
  | Binop (op, expr1, expr2) ->
      case evalList(configuration, {expr1, expr2}) of [configuration, {value1, value2}] ->
        return [configuration, evalBinop(op, value1, value2)]
      esac
  esac
}

fun evalWhile (expr, stmt, continue, configuration) {
  --printf("evalWhile: %s\n", expr.string);
  case eval(configuration, expr) of [configuration, value] ->
    if continue(value)
    then evalWhile(expr, stmt, continue, eval(configuration, stmt)[0])
    else [configuration, void]
    fi
  esac
}

public fun evalBinop (op, value1, value2) {
  case op of
    "*"  -> return value1 *  value2
  | "+"  -> return value1 +  value2
  | "-"  -> return value1 -  value2
  | "/"  -> return value1 /  value2
  | "%"  -> return value1 %  value2
  | "<"  -> return value1 <  value2
  | "<=" -> return value1 <= value2
  | ">"  -> return value1 >  value2
  | ">=" -> return value1 >= value2
  | "==" -> return value1 == value2
  | "!=" -> return value1 != value2
  | "&&" -> return value1 && value2
  | "!!" -> return value1 !! value2
  esac
}

-- Evaluates a program with a given input and returns an output
public fun evalExpr (input, expr) {
  case eval ([emptyState (), createWorld (input)], expr) of
    [c, _] -> c.snd.getOutput
  esac
}

fun zip(l1, l2) {
  case [l1, l2] of
    [{}, {}] -> {}
  | [e1:t1, e2:t2] -> [e1, e2] : zip(t1, t2)
  esac
}
